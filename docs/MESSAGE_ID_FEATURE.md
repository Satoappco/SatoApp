# Message ID Feature Documentation

## Overview

The Message ID feature ensures that every message exchanged between users and the assistant is tracked with a unique identifier. This enables better conversation traceability, audit logging, and reference management.

**Created:** 2025-11-20
**Status:** âœ… Implemented and Tested

---

## What's New

### Message IDs in Responses

All chat responses now include unique message identifiers for both user and assistant messages:

```json
{
  "message": "I'll analyze Facebook Ads for last month...",
  "thread_id": "thread-123",
  "needs_clarification": true,
  "ready_for_analysis": false,
  "intent": {...},
  "user_message_id": 1234,
  "assistant_message_id": 1235
}
```

### Streaming Chat

When using the streaming endpoint (`/api/v1/chat/stream`), message IDs are sent in a separate event after the assistant message is complete:

```
data: {"chunk": "H"}
data: {"chunk": "e"}
data: {"chunk": "l"}
data: {"chunk": "l"}
data: {"chunk": "o"}
data: {"metadata": {...}}
data: {"message_ids": {"user_message_id": 1234, "assistant_message_id": 1235}}
data: [DONE]
```

---

## API Changes

### ChatResponse Schema

The `ChatResponse` model has been updated to include two optional fields:

```python
class ChatResponse(BaseModel):
    message: str
    thread_id: str
    needs_clarification: bool
    ready_for_analysis: bool
    intent: Optional[Dict[str, Any]]
    user_message_id: Optional[int]  # NEW
    assistant_message_id: Optional[int]  # NEW
```

### Database Storage

Message IDs correspond to the `id` field in the `chat_traces` table where `record_type = 'message'`. These IDs are automatically generated by the database and are guaranteed to be unique.

---

## Use Cases

### 1. Message Reference and Threading

Use message IDs to reference specific messages in a conversation:

```python
# Retrieve a specific message
message = session.exec(
    select(ChatTrace).where(
        and_(
            ChatTrace.id == message_id,
            ChatTrace.record_type == RecordType.MESSAGE
        )
    )
).first()
```

### 2. Audit Logging

Track which messages were sent and when:

```python
# Log message activity
logger.info(f"User message {user_message_id} sent at {timestamp}")
logger.info(f"Assistant message {assistant_message_id} sent at {timestamp}")
```

### 3. Analytics and Metrics

Analyze message patterns and response times:

```python
# Calculate response time between user and assistant messages
user_msg = get_message(user_message_id)
assistant_msg = get_message(assistant_message_id)
response_time = assistant_msg.created_at - user_msg.created_at
```

### 4. Message Editing and Deletion

Reference specific messages for editing or deletion operations:

```python
# Mark message as deleted
message = get_message(message_id)
message.deleted_at = datetime.now(timezone.utc)
session.commit()
```

---

## Implementation Details

### Chat Endpoint (`/api/v1/chat`)

```python
# User message is saved first
user_message_record = trace_service.add_message(
    thread_id=thread_id,
    role="user",
    content=request.message
)
user_message_id = user_message_record.id if user_message_record else None

# ... process message ...

# Assistant message is saved after processing
assistant_message_record = trace_service.add_message(
    thread_id=thread_id,
    role="assistant",
    content=assistant_message
)
assistant_message_id = assistant_message_record.id if assistant_message_record else None

# Return both IDs in response
return ChatResponse(
    message=assistant_message,
    thread_id=thread_id,
    needs_clarification=needs_clarification,
    ready_for_analysis=ready_for_analysis,
    intent=intent,
    user_message_id=user_message_id,
    assistant_message_id=assistant_message_id
)
```

### Streaming Endpoint (`/api/v1/chat/stream`)

```python
async def generate():
    # Save user message
    user_message_record = trace_service.add_message(
        thread_id=thread_id,
        role="user",
        content=request.message
    )
    user_message_id = user_message_record.id if user_message_record else None

    # Stream response chunks
    full_response = ""
    async for chunk in workflow.stream_message(request.message):
        if chunk.get("type") == "content":
            char = chunk.get("chunk", "")
            full_response += char
            yield f"data: {json.dumps({'chunk': char})}\n\n"

    # Save assistant message after streaming completes
    assistant_message_record = trace_service.add_message(
        thread_id=thread_id,
        role="assistant",
        content=full_response
    )
    assistant_message_id = assistant_message_record.id if assistant_message_record else None

    # Send message IDs as separate event
    yield f"data: {json.dumps({'message_ids': {'user_message_id': user_message_id, 'assistant_message_id': assistant_message_id}})}\n\n"
    yield "data: [DONE]\n\n"
```

---

## Testing

### Test Coverage

A dedicated test validates that message IDs are properly returned:

```python
def test_chat_returns_message_ids(test_client, auth_token, test_user):
    """Test that chat endpoint returns message_id for both user and assistant messages"""
    response = test_client.post(
        "/api/v1/chat",
        json={
            "message": "Show me Facebook metrics for last month",
            "campaigner_id": test_user.id
        },
        headers={
            "Authorization": f"Bearer {auth_token}"
        }
    )
    assert response.status_code == 200
    data = response.json()

    # Verify message_ids are present in response
    assert "user_message_id" in data
    assert "assistant_message_id" in data

    # Verify message_ids are valid integers (not None)
    assert isinstance(data["user_message_id"], int)
    assert isinstance(data["assistant_message_id"], int)

    # Verify message_ids are different
    assert data["user_message_id"] != data["assistant_message_id"]
```

### Running Tests

```bash
# Run the message_id test
pytest tests/test_backend_chat_integration.py::test_chat_returns_message_ids -v

# Run all chat integration tests
pytest tests/test_backend_chat_integration.py -v
```

---

## Client Integration

### JavaScript/TypeScript Example

```typescript
// Regular chat
const response = await fetch('/api/v1/chat', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    message: 'Show me my campaign performance',
    thread_id: threadId
  })
});

const data = await response.json();
console.log('User message ID:', data.user_message_id);
console.log('Assistant message ID:', data.assistant_message_id);

// Streaming chat
const eventSource = new EventSource('/api/v1/chat/stream');

eventSource.addEventListener('message', (event) => {
  const data = JSON.parse(event.data);

  if (data.chunk) {
    // Append character to display
    appendToMessage(data.chunk);
  } else if (data.message_ids) {
    // Message IDs received after streaming completes
    console.log('User message ID:', data.message_ids.user_message_id);
    console.log('Assistant message ID:', data.message_ids.assistant_message_id);
  } else if (event.data === '[DONE]') {
    eventSource.close();
  }
});
```

### Python Client Example

```python
import requests

# Regular chat
response = requests.post(
    'http://localhost:8080/api/v1/chat',
    headers={'Authorization': f'Bearer {token}'},
    json={
        'message': 'Show me my campaign performance',
        'thread_id': thread_id
    }
)

data = response.json()
user_message_id = data['user_message_id']
assistant_message_id = data['assistant_message_id']

print(f"User message ID: {user_message_id}")
print(f"Assistant message ID: {assistant_message_id}")
```

---

## Migration Notes

### Backward Compatibility

The message ID fields are **optional** in the response schema, ensuring backward compatibility with existing clients:

- Old clients will continue to work without changes
- New clients can use the message IDs for enhanced functionality
- No database migration is required (uses existing `chat_traces.id` field)

### Upgrading Clients

To take advantage of message IDs:

1. Update your API client to expect `user_message_id` and `assistant_message_id` in responses
2. Handle the `message_ids` event in streaming responses
3. Store message IDs if you need to reference messages later
4. Update your UI to show message IDs (optional, for debugging)

---

## Best Practices

### 1. Always Store Message IDs

```typescript
// Store message IDs with your local message history
const messageHistory = {
  userMessages: [
    { id: data.user_message_id, content: userMessage, timestamp: new Date() }
  ],
  assistantMessages: [
    { id: data.assistant_message_id, content: data.message, timestamp: new Date() }
  ]
};
```

### 2. Use Message IDs for Error Reporting

```typescript
// Include message ID in error reports
if (error) {
  logger.error('Message processing failed', {
    user_message_id: data.user_message_id,
    assistant_message_id: data.assistant_message_id,
    error: error.message
  });
}
```

### 3. Reference Messages in Follow-ups

```typescript
// Reference previous messages in new requests
const response = await fetch('/api/v1/chat', {
  method: 'POST',
  body: JSON.stringify({
    message: 'Can you explain that in more detail?',
    thread_id: threadId,
    reference_message_id: previousAssistantMessageId  // Custom field
  })
});
```

---

## Troubleshooting

### Issue: Message IDs are null

**Cause:** The `add_message()` call failed or returned `None`.

**Solution:** Check database connectivity and ensure the conversation exists:

```python
# Verify conversation exists
conversation = trace_service.get_conversation(thread_id)
if not conversation:
    logger.error(f"Conversation not found: {thread_id}")
    # Create conversation first
    trace_service.create_conversation(thread_id, campaigner_id)
```

### Issue: Message IDs are the same

**Cause:** This should never happen as IDs are auto-generated by the database.

**Solution:** Check that both `add_message()` calls are executing and returning different records.

### Issue: Streaming doesn't send message_ids event

**Cause:** The streaming loop might be terminating early.

**Solution:** Ensure the assistant message is saved and the `message_ids` event is yielded after streaming completes.

---

## Related Documentation

- [Chat Trace Service Documentation](./CHAT_TRACE_SERVICE.md) - Core service for message storage
- [Chat API Documentation](../app/api/v1/routes/chat.py) - API endpoint implementation
- [Chat Trace Models](../app/models/chat_traces.py) - Database schema

---

## Support

For issues or questions:
1. Check the test file for usage examples: `tests/test_backend_chat_integration.py`
2. Review the API implementation: `app/api/v1/routes/chat.py`
3. Check database records: `SELECT * FROM chat_traces WHERE record_type = 'message'`
4. Review logs for message ID generation failures
