name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest-xdist pytest-html factory-boy faker testcontainers[postgresql] responses freezegun

    - name: Run linting
      run: |
        # Basic linting (would use flake8, black, mypy in real implementation)
        python -m py_compile app/**/*.py

    - name: Run unit tests
      env:
        DATABASE_URL: "sqlite:///:memory:"
        GEMINI_API_KEY: "dummy-key-for-testing"
      run: pytest tests/unit/ -v --cov=app --cov-report=xml --tb=short

    - name: Wait for PostgreSQL to be ready
      run: |
        echo "Waiting for PostgreSQL to be fully ready..."
        for i in {1..10}; do
          if pg_isready -h localhost -p 5432 -U postgres > /dev/null 2>&1; then
            echo "PostgreSQL is ready!"
            # Additional wait for full initialization
            sleep 2
            # Verify with actual query
            PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -c "SELECT 1" > /dev/null 2>&1 && break
          fi
          echo "Waiting... ($i/10)"
          sleep 1
        done

    - name: Run integration tests
      env:
        TEST_DATABASE_URL: "postgresql://postgres:postgres@localhost:5432/postgres"
        GEMINI_API_KEY: "dummy-key-for-testing"
      run: pytest tests/integration/ -v --tb=short

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: false

    - name: Generate test report
      env:
        DATABASE_URL: "sqlite:///:memory:"
        TEST_DATABASE_URL: "sqlite:///:memory:"
        GEMINI_API_KEY: "dummy-key-for-testing"
      run: pytest tests/ --html=reports/test-report.html --self-contained-html
      if: always()

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: reports/

  deploy-staging:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging

    steps:
    - uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Configure Docker for GCR
      run: |
        gcloud auth configure-docker

    - name: Load and validate environment variables
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        API_TOKEN: ${{ secrets.API_TOKEN }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        INTERNAL_AUTH_TOKEN: ${{ secrets.INTERNAL_AUTH_TOKEN }}
      run: |
        # Create temporary .env file from secrets
        cat > .env.dev.cloudrun.yaml << EOF
        GEMINI_API_KEY: "$GEMINI_API_KEY"
        API_TOKEN: "$API_TOKEN"
        DATABASE_URL: "$DATABASE_URL"
        DB_PASSWORD: "$DB_PASSWORD"
        INTERNAL_AUTH_TOKEN: "$INTERNAL_AUTH_TOKEN"
        EOF

        echo "‚úÖ Environment variables configured"

    - name: Build and push Docker image
      run: |
        PROJECT_ID=$(gcloud config get-value project)
        SERVICE_NAME="sato-backend-dev"
        IMAGE_NAME="gcr.io/$PROJECT_ID/$SERVICE_NAME"

        gcloud builds submit --tag $IMAGE_NAME .

        echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
        echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV

    - name: Deploy to Cloud Run (Staging)
      run: |
        REGION="me-west1"
        PROJECT_ID=$(gcloud config get-value project)
        CLOUD_SQL_INSTANCE="sato-db"

        gcloud run deploy $SERVICE_NAME \
          --image $IMAGE_NAME \
          --region=$REGION \
          --allow-unauthenticated \
          --memory 4Gi \
          --cpu 2 \
          --timeout 600 \
          --concurrency 5 \
          --max-instances 2 \
          --min-instances 0 \
          --execution-environment gen2 \
          --cpu-boost \
          --add-cloudsql-instances $PROJECT_ID:$REGION:$CLOUD_SQL_INSTANCE \
          --env-vars-file .env.dev.cloudrun.yaml

        SERVICE_URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
        echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
        echo "üåê Staging URL: $SERVICE_URL"

    - name: Cleanup
      if: always()
      run: |
        rm -f .env.dev.cloudrun.yaml

    - name: Send ClickUp success notification
      if: success()
      env:
        CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
        CLICKUP_LIST_ID: ${{ secrets.CLICKUP_LIST_ID }}
      run: |
        curl --request POST \
          --url "https://api.clickup.com/api/v2/list/${CLICKUP_LIST_ID}/task" \
          --header "Authorization: ${CLICKUP_API_TOKEN}" \
          --header 'Content-Type: application/json' \
          --data "{
            \"name\": \"‚úÖ Staging Deployment Success - ${GITHUB_SHA:0:7}\",
            \"description\": \"**Deployment Details:**\n- Branch: ${GITHUB_REF_NAME}\n- Commit: ${GITHUB_SHA}\n- Service URL: ${SERVICE_URL}\n- Triggered by: ${GITHUB_ACTOR}\n- Workflow: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\",
            \"status\": \"complete\",
            \"priority\": 3,
            \"tags\": [\"deployment\", \"staging\", \"success\"]
          }"

    - name: Send ClickUp failure notification
      if: failure()
      env:
        CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
        CLICKUP_LIST_ID: ${{ secrets.CLICKUP_LIST_ID }}
      run: |
        curl --request POST \
          --url "https://api.clickup.com/api/v2/list/${CLICKUP_LIST_ID}/task" \
          --header "Authorization: ${CLICKUP_API_TOKEN}" \
          --header 'Content-Type: application/json' \
          --data "{
            \"name\": \"‚ùå Staging Deployment Failed - ${GITHUB_SHA:0:7}\",
            \"description\": \"**Deployment Failed:**\n- Branch: ${GITHUB_REF_NAME}\n- Commit: ${GITHUB_SHA}\n- Triggered by: ${GITHUB_ACTOR}\n- Workflow: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\n\nPlease check the workflow logs for details.\",
            \"status\": \"to do\",
            \"priority\": 1,
            \"tags\": [\"deployment\", \"staging\", \"failed\"]
          }"

  deploy-production:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Configure Docker for GCR
      run: |
        gcloud auth configure-docker

    - name: Load and validate environment variables
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        API_TOKEN: ${{ secrets.API_TOKEN }}
        DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        DB_PASSWORD: ${{ secrets.PRODUCTION_DB_PASSWORD }}
        INTERNAL_AUTH_TOKEN: ${{ secrets.INTERNAL_AUTH_TOKEN }}
      run: |
        # Create temporary .env file from secrets
        cat > .env.prod.cloudrun.yaml << EOF
        GEMINI_API_KEY: "$GEMINI_API_KEY"
        API_TOKEN: "$API_TOKEN"
        DATABASE_URL: "$DATABASE_URL"
        DB_PASSWORD: "$DB_PASSWORD"
        INTERNAL_AUTH_TOKEN: "$INTERNAL_AUTH_TOKEN"
        EOF

        echo "‚úÖ Environment variables configured"

    - name: Build and push Docker image
      run: |
        PROJECT_ID=$(gcloud config get-value project)
        SERVICE_NAME="sato-backend"
        IMAGE_NAME="gcr.io/$PROJECT_ID/$SERVICE_NAME"

        gcloud builds submit --tag $IMAGE_NAME .

        echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
        echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV

    - name: Deploy to Cloud Run (Production)
      run: |
        REGION="me-west1"
        PROJECT_ID=$(gcloud config get-value project)
        CLOUD_SQL_INSTANCE="sato-db"

        gcloud run deploy $SERVICE_NAME \
          --image $IMAGE_NAME \
          --region=$REGION \
          --allow-unauthenticated \
          --memory 8Gi \
          --cpu 4 \
          --timeout 900 \
          --concurrency 2 \
          --max-instances 3 \
          --min-instances 1 \
          --execution-environment gen2 \
          --cpu-boost \
          --add-cloudsql-instances $PROJECT_ID:$REGION:$CLOUD_SQL_INSTANCE \
          --env-vars-file .env.prod.cloudrun.yaml

        SERVICE_URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
        echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
        echo "üåê Production URL: $SERVICE_URL"

    - name: Cleanup
      if: always()
      run: |
        rm -f .env.prod.cloudrun.yaml

    - name: Send ClickUp success notification
      if: success()
      env:
        CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
        CLICKUP_LIST_ID: ${{ secrets.CLICKUP_LIST_ID }}
      run: |
        curl --request POST \
          --url "https://api.clickup.com/api/v2/list/${CLICKUP_LIST_ID}/task" \
          --header "Authorization: ${CLICKUP_API_TOKEN}" \
          --header 'Content-Type: application/json' \
          --data "{
            \"name\": \"üöÄ Production Deployment Success - ${GITHUB_SHA:0:7}\",
            \"description\": \"**Deployment Details:**\n- Branch: ${GITHUB_REF_NAME}\n- Commit: ${GITHUB_SHA}\n- Service URL: ${SERVICE_URL}\n- Triggered by: ${GITHUB_ACTOR}\n- Workflow: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\",
            \"status\": \"complete\",
            \"priority\": 2,
            \"tags\": [\"deployment\", \"production\", \"success\"]
          }"

    - name: Send ClickUp failure notification
      if: failure()
      env:
        CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
        CLICKUP_LIST_ID: ${{ secrets.CLICKUP_LIST_ID }}
      run: |
        curl --request POST \
          --url "https://api.clickup.com/api/v2/list/${CLICKUP_LIST_ID}/task" \
          --header "Authorization: ${CLICKUP_API_TOKEN}" \
          --header 'Content-Type: application/json' \
          --data "{
            \"name\": \"üî• PRODUCTION Deployment FAILED - ${GITHUB_SHA:0:7}\",
            \"description\": \"**CRITICAL: Production Deployment Failed:**\n- Branch: ${GITHUB_REF_NAME}\n- Commit: ${GITHUB_SHA}\n- Triggered by: ${GITHUB_ACTOR}\n- Workflow: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\n\n‚ö†Ô∏è URGENT: Check workflow logs immediately!\",
            \"status\": \"to do\",
            \"priority\": 1,
            \"tags\": [\"deployment\", \"production\", \"failed\", \"urgent\"]
          }"